{"id":"ADR-000","title":"ADR Format and Process","status":"approved","decision":"Architecture Decision Records follow this JSONL format with required fields: id, title, status, decision, rationale, createdAt, updatedAt. Statuses: proposed → approved | rejected | deferred | suspended | superseded.","rationale":"Consistent format enables tooling, searchability, and clear decision history. JSONL allows line-by-line processing and easy appending.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["meta"],"categories":{"001-019":"Tooling & Infrastructure","020-039":"Code Quality & Patterns","040-059":"Web Framework & API","060-079":"Data & Storage","100-119":"UX Principles","120-139":"Testing & Quality Gates"}}
{"id":"ADR-001","title":"Python Version","status":"approved","decision":"Python 3.12+ (latest stable release)","rationale":"Modern syntax features (match statements, type parameter syntax), performance improvements, better error messages, long-term support. Always use the latest stable version for new projects.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","runtime"]}
{"id":"ADR-002","title":"Type Hints and Static Analysis","status":"approved","decision":"Strict type hints with mypy in strict mode (--strict flag)","rationale":"Catches bugs before runtime, improves code documentation, enables better IDE support, enforces explicit types. Use from __future__ import annotations for forward references.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","typing"],"config":{"mypy":{"strict":true,"warn_return_any":true,"warn_unused_ignores":true,"disallow_untyped_defs":true}}}
{"id":"ADR-003","title":"Testing Framework","status":"approved","decision":"pytest over unittest","rationale":"Simpler assertions, powerful fixtures, excellent plugin ecosystem (pytest-cov, pytest-asyncio, pytest-mock), less boilerplate, better test discovery, parametrized tests.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","testing"],"plugins":["pytest-cov","pytest-asyncio","pytest-mock","pytest-xdist"]}
{"id":"ADR-004","title":"Code Markers Convention","status":"approved","decision":"Two-tier marker system: (1) Inline markers (TODO, FIXME, HACK) for active development only—must be resolved before PR merge. (2) Structured tracking (issue tracker, metadata files) for persistent work items with ownership and priority.","rationale":"Unstructured markers accumulate as invisible technical debt. Requiring promotion to structured tracking ensures accountability and visibility.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["conventions","code-quality"]}
{"id":"ADR-005","title":"Async I/O","status":"approved","decision":"asyncio with aiofiles for file operations, httpx for HTTP clients","rationale":"Non-blocking I/O for better concurrency, native async/await syntax, aiofiles provides async file operations, httpx is modern async-first HTTP client replacing requests.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","async"],"libraries":{"files":"aiofiles","http":"httpx","database":"asyncpg or databases"}}
{"id":"ADR-006","title":"Package Manager","status":"approved","decision":"uv over pip/poetry/pipenv","rationale":"Extremely fast (10-100x faster than pip), written in Rust, drop-in pip replacement, handles virtual environments, lockfiles, and dependency resolution. Modern alternative that's gaining rapid adoption.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"],"commands":{"install":"uv pip install","sync":"uv pip sync requirements.lock","venv":"uv venv"}}
{"id":"ADR-007","title":"Linter and Formatter","status":"approved","decision":"Ruff for linting and formatting (replaces flake8, isort, black, pylint)","rationale":"All-in-one lint and format, 10-100x faster than alternatives (Rust-based), drop-in replacement for flake8/isort/black, excellent defaults, minimal config needed.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"],"config":{"line-length":100,"select":["E","F","W","I","UP","B","SIM","C4"]}}
{"id":"ADR-008","title":"Git Hooks","status":"approved","decision":"pre-commit over manual hooks","rationale":"Standardized hook management, automatic installation, language-agnostic, excellent ecosystem of hooks, easy sharing across team.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"],"hooks":["ruff","ruff-format","mypy","pytest"]}
{"id":"ADR-009","title":"Project Structure","status":"approved","decision":"src layout with src/{package_name}/ and separate tests/ directory","rationale":"Prevents accidental imports from project root, clear separation of source and tests, follows modern Python packaging best practices, works well with all build tools.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["conventions","architecture"],"structure":{"src/{pkg}":"Main package code","tests/":"Test files mirroring src structure","pyproject.toml":"Project configuration (PEP 621)","README.md":"Documentation"}}
{"id":"ADR-010","title":"Build and Packaging","status":"approved","decision":"pyproject.toml with hatchling or setuptools as build backend","rationale":"PEP 621 standardized metadata, single configuration file, modern Python packaging. Hatchling is lightweight and fast; setuptools for complex builds.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","build"],"alternatives":{"hatchling":"Simple, fast, modern default","setuptools":"Complex builds, C extensions","flit":"Minimal, pure Python only"}}
{"id":"ADR-011","title":"Configuration Management","status":"approved","decision":"pydantic-settings for configuration with environment variables","rationale":"Type-safe configuration, automatic environment variable parsing, validation, secrets handling, .env file support. Integrates seamlessly with Pydantic models.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","configuration"]}
{"id":"ADR-012","title":"Runtime Validation","status":"approved","decision":"Pydantic v2 for data validation and serialization","rationale":"Fast (Rust core in v2), excellent TypeScript-like validation, automatic JSON serialization, IDE autocomplete, widely adopted in Python ecosystem. Works with dataclasses via decorator.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","validation"]}
{"id":"ADR-013","title":"Logging","status":"approved","decision":"structlog over logging/loguru","rationale":"Structured logging with JSON output, context binding, excellent for production observability, integrates with standard library logging, type-safe, composable processors.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","observability"],"alternatives":{"loguru":"Simpler API, good for smaller projects","logging":"Standard library, verbose configuration"}}
{"id":"ADR-014","title":"Dead Code Detection","status":"approved","decision":"vulture for finding unused code, combined with Ruff's F401/F841 rules","rationale":"Vulture finds unused functions, variables, and classes. Ruff catches unused imports and variables. Together they provide comprehensive dead code detection.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","maintenance"]}
{"id":"ADR-015","title":"Virtual Environments","status":"approved","decision":"Always use virtual environments, managed by uv or venv","rationale":"Isolation prevents dependency conflicts, reproducible environments, project-specific dependencies. uv manages venvs automatically; fallback to python -m venv.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dx"]}
{"id":"ADR-016","title":"Dependency Specification","status":"approved","decision":"Pin all dependencies in requirements.lock, specify ranges in pyproject.toml","rationale":"Reproducible builds with lockfile, flexible development with version ranges. Use uv pip compile or pip-tools to generate lockfile from pyproject.toml.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","dependencies"]}
{"id":"ADR-020","title":"Code Quality Principles","status":"approved","decision":"Adopt DRY, SOLID, and Pythonic idioms while prioritizing shipping. Perfect is the enemy of good.","rationale":"Sustainable code requires proven principles balanced with pragmatic delivery. Follow PEP 20 (Zen of Python). Refactor when patterns emerge, not in anticipation.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","principles"],"principles":{"DRY":"Single authoritative representation for each piece of knowledge","SOLID":"Adapted for Python: favor composition, use protocols/ABCs for interfaces","Pythonic":"Explicit over implicit, simple over complex, readability counts"}}
{"id":"ADR-021","title":"Result Types for Error Handling","status":"approved","decision":"Use Result pattern via returns library or custom Result type. Reserve exceptions for truly exceptional cases.","rationale":"Makes failure explicit in type signatures, enables exhaustive error handling with match statements, reduces try-except proliferation, consistent patterns across codebase.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","patterns"],"pattern":"Result = Success[T] | Failure[E] with .map(), .bind() methods","library":"returns (dry-python/returns)"}
{"id":"ADR-022","title":"No Mock Data in Production Code","status":"approved","decision":"Mock data only in test files (test_*.py, *_test.py). Production code uses loading states, empty states, and error handling.","rationale":"Mock data in production creates confusion, makes debugging harder, and risks shipping to users. Forces proper implementation of data flows.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","testing"]}
{"id":"ADR-023","title":"Dataclasses and Protocols","status":"approved","decision":"Use dataclasses for data containers, Protocol for structural typing (duck typing with types)","rationale":"Dataclasses reduce boilerplate for data structures. Protocols enable interface definitions without inheritance, supporting Python's duck typing philosophy with static type checking.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","typing"],"usage":{"dataclass":"Immutable data containers (frozen=True)","Protocol":"Define expected interfaces without inheritance","TypedDict":"For dictionary shapes, especially JSON"}}
{"id":"ADR-024","title":"Context Managers","status":"approved","decision":"Use context managers (with statement) for all resource management","rationale":"Guarantees cleanup even on exceptions, clear resource scope, Pythonic pattern. Use contextlib for custom context managers.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","patterns"]}
{"id":"ADR-025","title":"Dependency Injection","status":"approved","decision":"Use dependency-injector or manual injection via constructor parameters","rationale":"Improves testability, decouples components, makes dependencies explicit. For simpler projects, manual injection via __init__ parameters is sufficient.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["code-quality","patterns","architecture"]}
{"id":"ADR-040","title":"Web Framework","status":"approved","decision":"FastAPI for APIs, Flask for simple web apps","rationale":"FastAPI provides automatic OpenAPI docs, Pydantic integration, async support, dependency injection, and excellent performance. Flask for simpler needs or when async isn't required.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["web","api"],"comparison":{"FastAPI":"Modern async, auto-docs, Pydantic, best for APIs","Flask":"Simple, synchronous, flexible, good ecosystem","Django":"Full-featured, batteries-included, ORM, admin"}}
{"id":"ADR-041","title":"ASGI Server","status":"approved","decision":"uvicorn for development, gunicorn with uvicorn workers for production","rationale":"Uvicorn is fast ASGI server built on uvloop. Gunicorn provides process management, graceful restarts, and worker management for production deployments.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["web","infrastructure"],"commands":{"dev":"uvicorn app:app --reload","prod":"gunicorn app:app -k uvicorn.workers.UvicornWorker -w 4"}}
{"id":"ADR-042","title":"API Protocol","status":"approved","decision":"REST by default, GraphQL (Strawberry) for complex nested data requirements","rationale":"REST is simpler, better caching, widely understood. GraphQL (via Strawberry) when dealing with deeply nested data, multiple clients with different data needs, or real-time subscriptions.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["api","architecture"],"libraries":{"rest":"FastAPI native","graphql":"Strawberry (async, type-safe, FastAPI integration)"}}
{"id":"ADR-043","title":"API Documentation","status":"approved","decision":"OpenAPI (Swagger) auto-generated by FastAPI","rationale":"FastAPI generates OpenAPI schema automatically from type hints and Pydantic models. Interactive docs at /docs (Swagger UI) and /redoc. No manual documentation drift.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["api","documentation"]}
{"id":"ADR-044","title":"HTTP Client","status":"approved","decision":"httpx over requests","rationale":"Async support, HTTP/2, connection pooling, timeout handling, requests-compatible API, actively maintained. Drop-in replacement with modern features.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","http"]}
{"id":"ADR-060","title":"Primary Database","status":"approved","decision":"PostgreSQL (version 16.x) over MySQL, SQLite, or NoSQL alternatives","rationale":"ACID compliance, excellent JSONB support for flexible schemas, mature ecosystem, strong Python tooling (asyncpg, psycopg3), GIN indexes for document queries, long-term support.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","infrastructure"]}
{"id":"ADR-061","title":"Database ORM/Query Builder","status":"approved","decision":"SQLAlchemy 2.0+ for complex apps, SQLModel for FastAPI projects","rationale":"SQLAlchemy 2.0 has modern async support, type hints, and is the industry standard. SQLModel (by FastAPI creator) combines SQLAlchemy with Pydantic for seamless FastAPI integration.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","tooling"],"comparison":{"SQLAlchemy":"Full-featured, complex queries, mature","SQLModel":"Pydantic + SQLAlchemy, great for FastAPI","Tortoise":"Django-like, async-first","databases":"Async query builder, lightweight"}}
{"id":"ADR-062","title":"Database Migrations","status":"approved","decision":"Alembic for SQLAlchemy projects","rationale":"Official SQLAlchemy migration tool, autogenerate migrations from model changes, version control for database schema, rollback support.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","tooling"]}
{"id":"ADR-063","title":"Async Database Driver","status":"approved","decision":"asyncpg for PostgreSQL async operations","rationale":"Fastest PostgreSQL driver for Python, native async, excellent performance, used by major frameworks. For sync: psycopg3.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","async"]}
{"id":"ADR-064","title":"Caching","status":"approved","decision":"Redis via redis-py (async) for distributed caching","rationale":"Fast in-memory cache, supports complex data structures, pub/sub for real-time features, session storage, rate limiting. Use functools.lru_cache for simple in-memory caching.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["database","caching","infrastructure"]}
{"id":"ADR-065","title":"Background Tasks","status":"approved","decision":"Celery for distributed tasks, or FastAPI BackgroundTasks for simple cases","rationale":"Celery provides distributed task queue, scheduling, retries, monitoring. For simple fire-and-forget tasks within a request, FastAPI's BackgroundTasks is sufficient.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["infrastructure","async"],"alternatives":{"Celery":"Distributed, Redis/RabbitMQ backend, monitoring","arq":"Lightweight, Redis-based, async-first","dramatiq":"Simple API, good defaults","BackgroundTasks":"FastAPI built-in, same process"}}
{"id":"ADR-066","title":"Task Scheduling","status":"approved","decision":"APScheduler or Celery Beat for scheduled tasks","rationale":"APScheduler for in-process scheduling, Celery Beat for distributed scheduled tasks. Avoid cron for application-level scheduling.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["infrastructure","scheduling"]}
{"id":"ADR-070","title":"CLI Framework","status":"approved","decision":"Typer over argparse/click","rationale":"Built on Click, automatic help generation, type hint-based arguments, excellent developer experience, shell completion support. By the creator of FastAPI.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["tooling","cli"]}
{"id":"ADR-071","title":"Environment Variables","status":"approved","decision":"python-dotenv for .env files, pydantic-settings for typed config","rationale":"python-dotenv loads .env files in development. pydantic-settings provides type-safe configuration with validation. Never commit secrets to version control.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["configuration","security"]}
{"id":"ADR-100","title":"Instant Visual Feedback","status":"approved","decision":"Every user action produces immediate visual feedback (<16ms for hover/drag, <50ms for property changes)","rationale":"Professional tools feel instant. Lag destroys direct manipulation illusion and user trust.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","performance"],"testQuestion":"Does it feel instant?"}
{"id":"ADR-101","title":"Undo Everything","status":"approved","decision":"Every state-modifying action is undoable. Undo history should be navigable.","rationale":"Fear of mistakes prevents experimentation. Users who can freely undo try more things and trust the tool more.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","state"],"testQuestion":"Can you Ctrl+Z this?"}
{"id":"ADR-102","title":"Progressive Disclosure","status":"approved","decision":"Simple things must be simple. Advanced features accessible but not in the way. UI scales from beginner to expert.","rationale":"New users are overwhelmed by complexity; experts frustrated by hidden features. Show basics by default, reveal advanced on demand.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","design"],"testQuestion":"Is simple stuff simple?"}
{"id":"ADR-103","title":"Production-Ready Output","status":"approved","decision":"Exported/generated code requires no cleanup before use in real projects","rationale":"If users must fix output, they question the tool's value. Output should match what a senior developer writes by hand.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","quality"],"testQuestion":"Would you ship this code?"}
{"id":"ADR-104","title":"Accessibility Native","status":"approved","decision":"The application must be accessible, and any output it generates must be accessible by default","rationale":"Accessible design improves usability for everyone. Accessibility debt is expensive to fix later.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","accessibility"],"testQuestion":"Can you use it without a mouse?"}
{"id":"ADR-105","title":"Performance Budget","status":"approved","decision":"Strict performance budget enforced. Features exceeding budget must be optimized or rejected.","rationale":"Performance degrades gradually then suddenly. Without a budget, death by a thousand cuts.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","performance"],"testQuestion":"Is it under budget?","budgets":{"apiResponse":"<100ms p95","startupTime":"<2s","memoryIdle":"<100MB"}}
{"id":"ADR-106","title":"API Consistency","status":"approved","decision":"Consistent API design across all endpoints. Follow REST conventions or GraphQL best practices.","rationale":"Inconsistent APIs confuse developers and increase integration time. Predictable patterns enable faster development.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["api","quality"],"testQuestion":"Is the API predictable?"}
{"id":"ADR-107","title":"State Persistence and Recovery","status":"approved","decision":"User work never lost. State persists across sessions. Crash recovery is automatic.","rationale":"Losing work destroys trust. Auto-save and recovery are table stakes for professional tools.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ux","reliability"],"testQuestion":"Will this survive a crash?"}
{"id":"ADR-120","title":"Testing Strategy","status":"approved","decision":"Minimum coverage thresholds (80% statements, 70% branches). Tests required for new code. Automated quality gates on PRs.","rationale":"Without enforced gates, technical debt accumulates silently. Coverage metrics provide objective quality signals.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","ci"],"thresholds":{"statements":80,"branches":70,"functions":80,"lines":80,"criticalPaths":95}}
{"id":"ADR-121","title":"Test Organization","status":"approved","decision":"tests/ directory mirrors src/ structure. Unit tests in test_*.py, integration tests in tests/integration/, fixtures in conftest.py","rationale":"Consistent structure aids discoverability. Separation of unit and integration tests enables faster feedback loops.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","conventions"]}
{"id":"ADR-122","title":"Mocking Strategy","status":"approved","decision":"Use pytest-mock (unittest.mock wrapper), prefer dependency injection over patching","rationale":"Dependency injection makes tests clearer and more maintainable. Use mocking sparingly for external services. Avoid over-mocking internal implementation.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","patterns"]}
{"id":"ADR-123","title":"Async Testing","status":"approved","decision":"pytest-asyncio for testing async code with async def test functions","rationale":"Native async test support, automatic event loop management, works with pytest fixtures.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","async"]}
{"id":"ADR-124","title":"API Testing","status":"approved","decision":"httpx with FastAPI TestClient for API testing, or pytest-httpx for mocking HTTP calls","rationale":"TestClient provides sync interface for async FastAPI apps. pytest-httpx mocks external HTTP calls cleanly.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["testing","api"]}
{"id":"ADR-130","title":"CI/CD Pipeline","status":"approved","decision":"GitHub Actions for CI, with linting, type checking, and tests on every PR","rationale":"Integrated with GitHub, easy configuration, good ecosystem of actions. Fail fast on quality issues.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["ci","infrastructure"],"stages":["lint (ruff)","type-check (mypy)","test (pytest)","security (bandit, safety)"]}
{"id":"ADR-131","title":"Security Scanning","status":"approved","decision":"bandit for code security analysis, safety for dependency vulnerabilities","rationale":"Automated security scanning catches common vulnerabilities early. Integrate into CI pipeline to prevent security regressions.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["security","ci"]}
{"id":"ADR-132","title":"Docker for Deployment","status":"approved","decision":"Multi-stage Dockerfile with slim Python base image","rationale":"Reproducible deployments, isolated environment, easy scaling. Multi-stage builds reduce image size. Use python:3.12-slim as base.","createdAt":"2025-01-01","updatedAt":"2025-01-01","tags":["infrastructure","deployment"]}